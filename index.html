<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚ùñ Component Library</title>
    <meta name="description" content="Explore our comprehensive UI component library with detailed documentation and examples.">
    <meta property="og:description" content="Explore our comprehensive UI component library with detailed documentation and examples.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="">
    <link rel="icon" type="image/png" href="assets/fav/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="assets/fav/favicon.svg" />
    <link rel="shortcut icon" href="assets/fav/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="assets/fav/apple-touch-icon.png" />
    <link rel="stylesheet" href="css/slider.css" />
    <link rel="stylesheet" href="css/comp_cards.css" />
    <link rel="stylesheet" href="css/app.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="stylesheet">
    <script type="module" src="js/ionicons/ionicons.esm.js"></script>
    <script nomodule src="js/ionicons/ionicons.js"></script>
    <style>
        h1 {
            margin-bottom: 1rem;
        }

        h2 {
            margin-bottom: 1rem;
        }

        p {
            line-height: 1.6;
            margin-bottom: 2rem;
        }

        section {
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 2rem;
            box-sizing: border-box;
        }

        .dark-section {
            background-color: #171717;
            color: #fff;
        }

        .content-container {
            max-width: 800px;
            margin: 0 auto;
            text-align: center;
        }

        .intro {
            font-size: 1.5rem;
            margin-bottom: 2rem;
        }

        /* Animation CSS */
        .has-mask-fill > span {
            position: relative;
            display: inline;
            -webkit-text-fill-color: rgba(0, 0, 0, 0.1);
            -webkit-background-clip: text;
            background-repeat: no-repeat;
            background-image: linear-gradient(var(--text-color), var(--text-color));
            background-size: 0% 100%;
        }

        .has-mask-fill.block-title > span {
            display: block;
        }

        [data-theme="dark"] .has-mask-fill > span {
            position: relative;
            display: inline;
            -webkit-text-fill-color: rgba(255, 255, 255, 0.1);
            -webkit-background-clip: text;
            background-repeat: no-repeat;
            background-image: linear-gradient(var(--text-color), var(--text-color));
            background-size: 0% 100%;
        }

        .has-opacity span {
            opacity: 0.2;
        }

        /* New animation classes for elements */
        .reveal-on-scroll {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .reveal-on-scroll.revealed {
            opacity: 1;
            transform: translateY(0);
        }

        .fade-in-on-scroll {
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .fade-in-on-scroll.revealed {
            opacity: 1;
        }

        .scale-in-on-scroll {
            opacity: 0;
            transform: scale(0.97);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .scale-in-on-scroll.revealed {
            opacity: 1;
            transform: scale(1);
        }

        .slide-in-left-on-scroll {
            opacity: 0;
            /*transform: translateX(-30px);*/
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .slide-in-left-on-scroll.revealed {
            opacity: 1;
            transform: translateX(0);
        }

        .slide-in-right-on-scroll {
            opacity: 0;
            /*transform: translateX(30px);*/
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .slide-in-right-on-scroll.revealed {
            opacity: 1;
            transform: translateX(0);
        }

        /* Add styles for nested component buttons */
        .nested-components-container {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin: 18px 0;
        }

        .nested-component-button {
            display: flex;
            align-items: center;
            padding: 8px 16px;
            background: var(--background-color);
            border: 1px solid var(--border-color);
            border-radius: 24px;
            font-size: 14px;
            color: var(--text-color);
            text-decoration: none;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .nested-component-button .diamond-icon {
            margin-left: 8px;
            transform: scale(0.7);
        }

        /* Dark theme support */

        .nested-components-section {
            margin-top: -2rem;
            padding: 1.5rem;
            /* background: var(--card-bg); */
            max-width: 900px;
            border-radius: 8px;
        }

        .nested-components-section .section-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-color);
        }

        .nested-components-section .section-description {
            font-size: 0.8rem;
            color: var(--description-color)!important;
            margin-bottom: 1rem;
        }

        .nested-components-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            margin-top: 1rem;
        }

        .nested-component-button {
            display: inline-flex;
            align-items: center;
            padding: 0.5rem 1rem;
            background: var(--button-bg);
            border: 1.5px solid #d4d6da;
            border-radius: 20px;
            color: var(--text-color);
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            box-shadow: 0px 0px 0px var(--button-bg-hover),0px 1px 1px var(--button-bg-hover);
            gap: 0.5rem;
        }
        [data-theme="dark"] .nested-component-button {
            display: inline-flex;
            align-items: center;
            padding: 0.5rem 1rem;
            background: var(--table-bg);
            border: 1.5px solid var(--border-color);
            border-radius: 20px;
            color: var(--text-color);
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            box-shadow: none;
            gap: 0.5rem;
        }

        .nested-component-button:hover {
            background: var(--card-bg);
            box-shadow: 0px 1px 2px var(--button-bg-hover),0px 1px 3px #02081425;
        }
        [data-theme="dark"] .nested-component-button:hover {
            background: var(--border-color);
            border-color: var(--border-color);
            box-shadow: none;
        }

        .nested-component-button .diamond-icon {
            transform: scale(0.7);
        }

        .nested-section-header {
            display: flex;
            align-items: center;
            gap: .6rem;
            margin-bottom: 1rem;
        }

        .nested-components-section .section-title {
            font-size: .9rem;
            font-weight: 600;
            margin: 0;
            color: var(--text-color);
            white-space: nowrap;
        }

        .nested-components-section .section-description {
            font-size: .9rem;
            font-weight: 400;
            margin: 0;
            color: var(--text-color);
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="breadcrumb-container" id="breadcrumbContainer">
            <div class="breadcrumb" id="breadcrumb"></div>
        </div>
        <div class="sidebar" id="sidebar">
            <div class="sidebar-search">
                <div class="search-container">
                    <input type="text" class="search-input" id="sidebarSearch" placeholder="Search components..." aria-label="Search components">
                    <img src="assets/search.svg" alt="Search" class="search-icon">
                </div>
                <div class="no-results" id="noResults">No matching components found</div>
            </div>
            <div class="sidebar-menu" id="sidebar-menu">
                <!-- Menu items will be generated by JavaScript -->
            </div>
        </div>
        <div class="fab-container">
            <button class="fab" onclick="openHowToModal()">
                <ion-icon name="help-circle-outline"></ion-icon>
            </button>
        </div>
        <div class="fab-container" id="scrollToTopFabcontainer">
            <button id="scrollToTopFab" class="fab" onclick="scrollToTop()">
                <ion-icon name="arrow-up-circle-outline"></ion-icon>
            </button>
        </div>
        <button class="sortFab" id="sortFab" onclick="toggleSidebarSorting()">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                <path d="M21.3,7.6h-6.9c-.9,0-1.5-.7-1.5-1.5h0c0-.9.7-1.5,1.5-1.5h6.9c.9,0,1.5.7,1.5,1.5h0c0,.9-.7,1.5-1.5,1.5ZM22.8,11.7h0c0-.9-.7-1.5-1.5-1.5h-6.2c-.9,0-1.5.7-1.5,1.5h0c0,.9.7,1.5,1.5,1.5h6.2c.9,0,1.5-.7,1.5-1.5ZM22.8,17.2h0c0-.9-.7-1.5-1.5-1.5h-2.8c-.9,0-1.5.7-1.5,1.5h0c0,.9.7,1.5,1.5,1.5h2.8c.9,0,1.5-.7,1.5-1.5ZM2.9,18.8c-.4,0-.7-.1-.9-.3s-.4-.5-.4-.8,0-.6.2-1.1l3.5-10.1c.2-.7.5-1.1.8-1.4s.8-.4,1.4-.4,1,.1,1.4.4.6.8.8,1.4l3.5,10.1c.1.4.2.8.2,1.1s-.1.7-.4.9-.6.3-1,.3-.7-.1-.9-.3-.4-.6-.5-1l-.8-2.4h-4.9l-.8,2.4c-.1.5-.3.8-.5,1s-.5.3-.9.3ZM5.8,13h3.7l-1.8-5.7h-.1l-1.8,5.7Z" />
            </svg>
            <span class="sortFab-tooltip">Default Category Sorting</span>
        </button>
        <button class="sortFab" id="closeFab" onclick="closeSidebarOnMobile()">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                <path d="M14.9,12l4.9-4.9c.7-.7.7-1.8,0-2.5h0c-.7-.7-1.8-.7-2.5,0l-4.9,4.9-4.9-4.9c-.7-.7-1.8-.7-2.5,0h0c-.7.7-.7,1.9,0,2.5l4.9,4.9-4.9,4.9c-.7.7-.7,1.8,0,2.5h0c.7.7,1.8.7,2.5,0l4.9-4.9,4.9,4.9c.7.7,1.8.7,2.5,0h0c.7-.7.7-1.9,0-2.5l-4.9-4.9Z" />
            </svg>
        </button>
        <button id="sidebar-toggle" class="sidebar-toggle" aria-label="Toggle Sidebar">
            <ion-icon name="menu"></ion-icon>
        </button>
        <!-- Theme Toggle Switch -->
        <div class="theme-switch-container">
            <label class="theme-switch">
                <input type="checkbox" id="theme-toggle">
                <span class="theme-slider"></span>
            </label>
            <span class="theme-icon">üåô</span>
        </div>
        <!-- Add the new navigation arrows with tooltips -->
        <div class="section-nav-arrows">
            <button class="nav-arrow up" onclick="navigateMenuItem('up')">
                <ion-icon name="chevron-up-outline"></ion-icon>
                <span class="tooltip-up"><span id="prevPageName"></span></span>
            </button>
            <button class="nav-arrow down" onclick="navigateMenuItem('down')">
                <ion-icon name="chevron-down-outline"></ion-icon>
                <span class="tooltip-down"><span id="nextPageName"></span></span>
            </button>
        </div>
        <div class="content" id="content">
            <!-- Loading indicator -->
            <div id="loading" class="loading">
                <div class="spinner"></div>
                <p class="has-opacity">Loading component...</p>
            </div>
            <div class="components-grid">
                <!-- Component Card -->
                <div class="component-item">
                    <div class="component-icon"></div>
                    <div class="component-info">
                        <h3 class="component-title">Accordion</h3>
                        <p class="component-card-description">Info Text</p>
                    </div>
                </div>
                <!-- Component Card -->
                <div class="component-item">
                    <div class="component-icon"></div>
                    <div class="component-info">
                        <h3 class="component-title">Badges & Tags</h3>
                        <p class="component-card-description">Info Text</p>
                    </div>
                </div>
                <!-- Component Card -->
                <div class="component-item">
                    <div class="component-icon"></div>
                    <div class="component-info">
                        <h3 class="component-title">Button</h3>
                        <p class="component-card-description">Info Text</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
        <!-- Required JavaScript Libraries -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.4/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.4/ScrollTrigger.min.js"></script>
    <script src="js/app.js"></script>
    <script>
        let toggle = true;
        let menuData = []; // Declare global menuData
        let isAlphabeticalSort = false;

        // Function to initialize scroll animations for dynamically loaded content
        function initializeScrollAnimations() {
            console.log('Initializing scroll animations for dynamic content');

            // Clear any existing ScrollTrigger instances to prevent duplicates
            ScrollTrigger.getAll().forEach(trigger => trigger.kill());

            // Process has-mask-fill elements
            $('.has-mask-fill').each(function() {
                // Skip if already processed
                if ($(this).find('span').length > 0) return;

                var words = $(this).text();
                var total = words;
                $(this).empty();
                $(this).append($("<span />").text(words));
            });

            // Special handling for block-title elements
            $('.has-mask-fill.block-title').each(function() {
                // Skip if already processed
                if ($(this).find('span').length > 0) return;

                var words = $(this).text().split(" ");
                var total = words.length;
                $(this).empty();
                for (let index = 0; index < total; index++) {
                    $(this).append($("<span />").text(words[index] + " "));
                }
            });

            // Animate has-mask-fill elements
            var hasMaskFill = gsap.utils.toArray('.has-mask-fill');
            hasMaskFill.forEach(function(hMaskFill) {
                var spanFillMask = hMaskFill.querySelectorAll("span");
                gsap.to(spanFillMask, {
                    scrollTrigger: {
                        trigger: hMaskFill,
                        start: "top 85%",
                        end: () => `+=${hMaskFill.offsetHeight * 2}`,
                        scrub: 1,
                    },
                    duration: 1,
                    backgroundSize: "200% 100%",
                    stagger: 0.5,
                    ease: "none",
                });
            });

            // Process has-opacity elements
            $('.has-opacity').each(function() {
                // Skip if already processed
                if ($(this).find('span').length > 0) return;

                var words = $(this).text().split(" ");
                var total = words.length;
                $(this).empty();
                for (let index = 0; index < total; index++) {
                    $(this).append($("<span />").text(words[index] + " "));
                }
            });

            // Animate has-opacity elements
            var hasOpacity = gsap.utils.toArray('.has-opacity');
            hasOpacity.forEach(function(hOpacity) {
                var spanOpacity = hOpacity.querySelectorAll("span");
                gsap.to(spanOpacity, {
                    scrollTrigger: {
                        trigger: hOpacity,
                        start: "top 85%",
                        end: () => `+=${hOpacity.offsetHeight}`,
                        scrub: 1,
                    },
                    duration: 1,
                    opacity: 1,
                    stagger: 0.5,
                    ease: "none",
                });
            });
        }

        // Function to initialize scroll animations for elements like cards, videos, and images
        function initializeElementScrollAnimations() {
            console.log('Initializing element scroll animations');

            // Apply immediate fade-in animation to component cards
            $('.component-item').not('.animation-applied').each(function(index) {
                const item = $(this);
                // Add animation class and delay
                item.addClass('animation-applied');
                // Set animation delay before adding the animation class
                item.css('animation-delay', `${index * 0.1}s`);
                // Use requestAnimationFrame to ensure opacity: 0 is applied first
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        item.addClass('fade-in-immediate');
                    });
                });
            });

            // Apply animation classes to images
            $('img:not(.animation-applied):not([src*="icon"]):not([src*="logo"])').each(function() {
                $(this).addClass('fade-in-on-scroll animation-applied');
            });

            // Apply animation classes to videos and video containers
            $('.video-container:not(.animation-applied), video:not(.animation-applied)').each(function() {
                $(this).addClass('scale-in-on-scroll animation-applied');
            });

            // Apply animation to icon items
            $('.icon-item:not(.animation-applied)').each(function(index) {
                $(this).addClass('slide-in-left-on-scroll animation-applied');
                // Add staggered delay based on index
                $(this).css('transition-delay', `${index * 0.05}s`);
            });

            // Apply animation to grid items
            $('.grid-item:not(.animation-applied)').each(function(index) {
                if (index % 2 === 0) {
                    $(this).addClass('slide-in-left-on-scroll animation-applied');
                } else {
                    $(this).addClass('slide-in-right-on-scroll animation-applied');
                }
            });

            // Create an Intersection Observer to handle the reveal for scroll-based animations
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('revealed');
                        // Unobserve after revealing to improve performance
                        observer.unobserve(entry.target);
                    }
                });
            }, {
                root: null,
                threshold: 0.15,
                rootMargin: '0px 0px -50px 0px'
            });

            // Observe all elements with scroll animation classes (except component items which now use immediate animation)
            document.querySelectorAll('.fade-in-on-scroll, .scale-in-on-scroll, .slide-in-left-on-scroll, .slide-in-right-on-scroll').forEach(element => {
                observer.observe(element);
            });
        }

        function sortMenuDataAlphabetically(data) {
            const firstStepsIndex = data.findIndex(item => item.category === "First Steps");
            let firstStepsCategory = null;
            if (firstStepsIndex !== -1) {
                firstStepsCategory = data[firstStepsIndex];
            }
            const dataWithoutFirstSteps = data.filter(item => item.category !== "First Steps");
            const sortedData = [...dataWithoutFirstSteps].sort((a, b) => a.category.localeCompare(b.category));
            if (firstStepsCategory) {
                sortedData.unshift(firstStepsCategory);
            }
            return sortedData;
        }
        function regenerateSidebarMenu(sortedData) {
            const currentActiveItem = document.querySelector('.category-item.active');
            const currentActiveItemName = currentActiveItem ? currentActiveItem.getAttribute('data-item') : null;
            const currentActiveItemPage = currentActiveItem ? currentActiveItem.getAttribute('data-page') : null;
            const sidebarMenu = document.getElementById('sidebar-menu');
            const sortToggle = document.getElementById('sort-toggle-icon');
            sidebarMenu.innerHTML = '';
            sidebarMenu.appendChild(sortToggle.parentElement);
            let reorderedData = [...sortedData];
            const firstStepsIndex = reorderedData.findIndex(item => item.category === "First Steps");
            if (firstStepsIndex > 0) {
                const firstStepsCategory = reorderedData.splice(firstStepsIndex, 1)[0];
                reorderedData.unshift(firstStepsCategory);
            }
            reorderedData.forEach((menuItem) => {
                const categoryElement = document.createElement('div');
                categoryElement.className = 'category';
                if (menuItem.category === "First Steps") {
                    categoryElement.classList.add('category-pinned');
                }
                categoryElement.innerHTML = `
                <div class="category-header">
                    ${menuItem.category}
                    <span class="toggle-icon">‚óã</span>
                </div>
                <div class="category-items">
                    ${menuItem.items.map(item => {
                    const itemId = item.toLowerCase().replace(/\s+/g, '-').replace(/\//g, '-');
                    const isActive = item === currentActiveItemName ? "active" : "";
                    return `
                            <a href="#" class="category-item ${isActive}" data-item="${item}" data-page="${itemId}">
                                ${item}
                                <span class="category-item-indicator"></span>
                            </a>
                        `;
                }).join('')}
                </div>
            `;
                sidebarMenu.appendChild(categoryElement);
                if (menuItem.items.includes(currentActiveItemName)) {
                    categoryElement.classList.add('active');
                    categoryElement.querySelector('.toggle-icon').textContent = '‚¨§';
                }
            });
            document.querySelectorAll('.category-header').forEach(header => {
                header.addEventListener('click', () => {
                    const parent = header.parentElement;
                    const toggleIcon = header.querySelector('.toggle-icon');
                    const isActive = parent.classList.contains('active');
                    document.querySelectorAll('.category').forEach(cat => {
                        cat.classList.remove('active');
                        cat.querySelector('.toggle-icon').textContent = '‚óã';
                    });
                    document.querySelectorAll('.category-item').forEach(i => {
                        i.classList.remove('active');
                    });
                    if (!isActive) {
                        parent.classList.add('active');
                        toggleIcon.textContent = '‚¨§';
                        const firstItem = parent.querySelector('.category-item');
                        if (firstItem) {
                            firstItem.classList.add('active');
                            const pageName = firstItem.getAttribute('data-page');
                            loadContent(pageName);
                            updateNavigationTooltips();
                            scrollToTop();
                            closeSidebarOnMobile();
                            // Add scroll to category items
                            scrollToCategoryItems(parent);
                        }
                    }
                });
            });
            addCategoryItemListeners();
            if (currentActiveItemPage) {
                loadContent(currentActiveItemPage);
            }
        }
        function toggleSidebarSorting() {
            isAlphabeticalSort = !isAlphabeticalSort;
            const sortFab = document.getElementById('sortFab');
            if (isAlphabeticalSort) {
                sortFab.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                <path d="M11,14.9l-3.5,3.5c-.3.3-.7.4-1,.4-.4,0-.7,0-1-.4l-3.5-3.5c-.5-.5-.5-1.3,0-1.9.5-.5,1.3-.5,1.9,0l1.4,1.4V5.8c0-.7.6-1.3,1.3-1.3s1.3.6,1.3,1.3v8.5l1.4-1.4c.5-.5,1.3-.5,1.9,0s.5,1.3,0,1.9ZM22.8,6.1h0c0-.9-.7-1.5-1.5-1.5h-6.9c-.9,0-1.5.7-1.5,1.5h0c0,.9.7,1.5,1.5,1.5h6.9c.9,0,1.5-.7,1.5-1.5ZM21.3,13.2h-6.2c-.9,0-1.5-.7-1.5-1.5h0c0-.9.7-1.5,1.5-1.5h6.2c.9,0,1.5.7,1.5,1.5h0c0,.9-.7,1.5-1.5,1.5ZM21.3,18.8h-2.8c-.9,0-1.5-.7-1.5-1.5h0c0-.9.7-1.5,1.5-1.5h2.8c.9,0,1.5.7,1.5,1.5h0c0,.9-.7,1.5-1.5,1.5Z"/>
            </svg>
            <span class="sortFab-tooltip">Default Category Sorting</span>`;
                const sortedMenuData = sortMenuDataAlphabetically(menuData);
                regenerateSidebarMenu(sortedMenuData);
            } else {
                sortFab.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                <path d="M21.3,7.6h-6.9c-.9,0-1.5-.7-1.5-1.5h0c0-.9.7-1.5,1.5-1.5h6.9c.9,0,1.5.7,1.5,1.5h0c0,.9-.7,1.5-1.5,1.5ZM22.8,11.7h0c0-.9-.7-1.5-1.5-1.5h-6.2c-.9,0-1.5.7-1.5,1.5h0c0,.9.7,1.5,1.5,1.5h6.2c.9,0,1.5-.7,1.5-1.5ZM22.8,17.2h0c0-.9-.7-1.5-1.5-1.5h-2.8c-.9,0-1.5.7-1.5,1.5h0c0,.9.7,1.5,1.5,1.5h2.8c.9,0,1.5-.7,1.5-1.5ZM2.9,18.8c-.4,0-.7-.1-.9-.3s-.4-.5-.4-.8,0-.6.2-1.1l3.5-10.1c.2-.7.5-1.1.8-1.4s.8-.4,1.4-.4,1,.1,1.4.4.6.8.8,1.4l3.5,10.1c.1.4.2.8.2,1.1s-.1.7-.4.9-.6.3-1,.3-.7-.1-.9-.3-.4-.6-.5-1l-.8-2.4h-4.9l-.8,2.4c-.1.5-.3.8-.5,1s-.5.3-.9.3ZM5.8,13h3.7l-1.8-5.7h-.1l-1.8,5.7Z" />
            </svg>
            <span class="sortFab-tooltip">Alphabetical Sorting</span>`;
                regenerateSidebarMenu(menuData);
            }
        }
        const sidebarMenu = document.getElementById('sidebar-menu');
        const contentContainer = document.getElementById('content');
        const loadingIndicator = document.getElementById('loading');
        menuData.forEach((menuItem, index) => {
            const categoryElement = document.createElement('div');
            categoryElement.className = 'category';
            if (menuItem.category === "First Steps") {
                categoryElement.classList.add('active');
            }
            categoryElement.innerHTML = `
                <div class="category-header">
                    ${menuItem.category}
                    <span class="toggle-icon">${menuItem.category === "UI component lib" ? '‚¨§' : '‚óã'}</span>
                </div>
                <div class="category-items">
                    ${menuItem.items.map(item => {
                    const isActive = item === "UI component lib" ? "active" : "";
                    const itemId = item.toLowerCase().replace(/\s+/g, '-').replace(/\//g, '-');
                    return `
                            <a href="#" class="category-item ${isActive}" data-item="${item}" data-page="${itemId}">
                                ${item}
                                <span class="category-item-indicator"></span>
                            </a>
                        `;
                }).join('')}
                </div>
            `;
            sidebarMenu.appendChild(categoryElement);
        });
        function scrollToTop() {
            window.scrollTo({
                top: 0,
                behavior:"smooth"
            });
        }

        // Add this code after the existing scrollToTop function
        const scrollToTopFab = document.getElementById('scrollToTopFab');

        // Add scroll event listener
        window.addEventListener('scroll', () => {
            // Show button after scrolling down 300px
            if (window.scrollY > 300) {
                scrollToTopFab.style.opacity = '1';
                scrollToTopFab.style.visibility = 'visible';
            } else {
                scrollToTopFab.style.opacity = '0';
                scrollToTopFab.style.visibility = 'hidden';
            }
        });


        const componentRepository = {};
        function populateComponentRepository() {
            menuData.forEach(category => {
                category.items.forEach(item => {
                    const itemId = item.toLowerCase().replace(/\s+/g, '-').replace(/\//g, '-');
                    if (!componentRepository[itemId]) {
                        componentRepository[itemId] = {
                            name: item,
                            description: "",
                            figmaLink: "",
                            figmaButtonText: item,
                            imagePath1: "",
                            imagePath2: ""
                        };
                    }
                });
            });
        }
        function initializeLottieAnimations() {
            const lottieContainers = document.querySelectorAll('[data-lottie-path]');
            lottieContainers.forEach(container => {
                const path = container.getAttribute('data-lottie-path');
                const loop = container.getAttribute('data-lottie-loop') !== 'false';
                const autoplay = container.getAttribute('data-lottie-autoplay') !== 'false';
                fetch(path)
                    .then(response => response.json())
                    .then(animationData => {
                        const animation = lottie.loadAnimation({
                            container: container,
                            renderer: 'svg',
                            loop: loop,
                            autoplay: autoplay,
                            animationData: animationData
                        });
                        if (!autoplay) {
                            container.style.cursor = 'pointer';
                            container.addEventListener('click', () => {
                                if (animation.isPaused) {
                                    animation.play();
                                } else {
                                    animation.pause();
                                }
                            });
                        }
                    })
                    .catch(error => {
                        console.error('Error loading Lottie animation:', error);
                        container.innerHTML = 'Failed to load animation';
                    });
            });
        }
        function initializeTabSwitching() {
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabContents = document.querySelectorAll('.tab-content');
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    tabContents.forEach(content => content.classList.remove('active'));
                    button.classList.add('active');
                    const tabId = `${button.dataset.tab}-tab`;
                    const tabContent = document.getElementById(tabId);
                    if (tabContent) {
                        tabContent.classList.add('active');
                    }
                });
            });
        }
        async function loadContent(pageName) {
            try {
                loadingIndicator.classList.add('active');
                contentContainer.classList.add('fade-out');

                // Wait for the fade-out transition to complete
                await new Promise(resolve => setTimeout(resolve, 200));

                const allCategories = document.querySelectorAll('.category');
                const allItems = document.querySelectorAll('.category-item');
                const targetItem = Array.from(allItems).find(item => item.getAttribute('data-page') === pageName);

                // Update breadcrumb
                const breadcrumbContainer = document.getElementById('breadcrumbContainer');
                const breadcrumb = document.getElementById('breadcrumb');

                if (pageName === 'ui-component-lib') {
                    breadcrumbContainer.classList.remove('visible');
                } else {
                    breadcrumbContainer.classList.add('visible');
                    let breadcrumbHTML = '';

                    // Add home link
                    breadcrumbHTML += `
                        <div class="breadcrumb-item">
                            <a href="/index.html">Component Library</a>
                        </div>
                    `;

                    if (targetItem) {
                        const parentCategory = targetItem.closest('.category');
                        if (parentCategory) {
                            const categoryHeader = parentCategory.querySelector('.category-header');
                            const categoryName = categoryHeader.textContent.trim();

                            // Add category
                            breadcrumbHTML += `
                                <div class="breadcrumb-item">
                                    <a href="/index.html?page=${categoryName.toLowerCase().replace(/\s+/g, '-').replace(/\//g, '-')}">${categoryName}</a>
                                </div>
                            `;

                            // Add all items in the category
                            const categoryItems = parentCategory.querySelectorAll('.category-item');
                            categoryItems.forEach((item, index) => {
                                const itemName = item.textContent.trim();
                                const itemPage = item.getAttribute('data-page');
                                const isActive = item === targetItem;

                                breadcrumbHTML += `
                                    <div class="breadcrumb-item ${isActive ? 'active' : ''}">
                                        ${isActive ? `‚ùñ ${itemName}` : `<a href="/index.html?page=${itemPage}">${itemName}</a>`}
                                    </div>
                                `;
                            });
                        }
                    }

                    breadcrumb.innerHTML = breadcrumbHTML;
                }

                if (targetItem) {
                    allItems.forEach(i => i.classList.remove('active'));
                    targetItem.classList.add('active');
                    allCategories.forEach(cat => {
                        cat.classList.remove('active');
                        cat.querySelector('.toggle-icon').textContent = '‚óã';
                    });
                    const parentCategory = targetItem.closest('.category');
                    if (parentCategory) {
                        parentCategory.classList.add('active');
                        parentCategory.querySelector('.toggle-icon').textContent = ' ‚¨§';
                    }
                }

                // Update URL without reloading the page
                const newUrl = pageName === 'ui-component-lib' ? '/index.html' : `/index.html?page=${pageName}`;
                window.history.pushState({ page: pageName }, '', newUrl);

                // Update meta tags and title
                const componentData = componentRepository[pageName];
                let pageTitle = '‚ùñ Component Library';
                let pageDescription = 'Explore our comprehensive UI component library with detailed documentation and examples.';

                if (componentData) {
                    const componentName = componentData.name;
                    pageTitle = `‚ùñ ${componentName} | Component Library`;
                    pageDescription = componentData.description || `Learn about the ${componentName} component in our UI library.`;
                }

                // Update document title
                document.title = pageTitle;
                // Update meta description
                let metaDescription = document.querySelector('meta[name="description"]');
                if (!metaDescription) {
                    metaDescription = document.createElement('meta');
                    metaDescription.name = 'description';
                    document.head.appendChild(metaDescription);
                }
                metaDescription.content = pageDescription;

                // Update Open Graph meta tags
                let ogTitle = document.querySelector('meta[property="og:title"]');
                let ogDescription = document.querySelector('meta[property="og:description"]');
                let ogUrl = document.querySelector('meta[property="og:url"]');

                if (!ogTitle) {
                    ogTitle = document.createElement('meta');
                    ogTitle.setAttribute('property', 'og:title');
                    document.head.appendChild(ogTitle);
                }
                ogTitle.content = pageTitle;

                if (!ogDescription) {
                    ogDescription = document.createElement('meta');
                    ogDescription.setAttribute('property', 'og:description');
                    document.head.appendChild(ogDescription);
                }
                ogDescription.content = pageDescription;

                if (!ogUrl) {
                    ogUrl = document.createElement('meta');
                    ogUrl.setAttribute('property', 'og:url');
                    document.head.appendChild(ogUrl);
                }
                ogUrl.content = window.location.href;

                if (pageName === 'ui-component-lib') {
                    loadingIndicator.classList.remove('active');
                    const contentHeader = `
                        <div class="content-header">
                            <h1 class="content-title">‚ùñ Component Library</h1>
                            <p class="content-subtitle">Select a component category to explore</p>
                        </div>
                    `;
                    let categoriesHTML = '<div class="components-grid">';
                    await Promise.all(menuData.map(async category => {
                        if (category.category !== "First Steps") {
                            const categoryId = category.category.toLowerCase().replace(/\s+/g, '-').replace(/\//g, '-');
                            const lottiePath = `assets/lottie/${categoryId}.json`;
                            const specificImagePath = `assets/cards/${categoryId}.webp`;
                            const fallbackImagePath = 'assets/img/component.png';
                            let iconContent = '';

                            try {
                                // Check for Lottie file
                                const lottieResponse = await fetch(lottiePath);
                                if (lottieResponse.ok) {
                                    iconContent = `<div class="animation-container" data-lottie-path="${lottiePath}" data-rederer="svg"></div>`;
                                } else {
                                    // Check for specific image if Lottie not found
                                    const imageResponse = await fetch(specificImagePath);
                                    if (imageResponse.ok) {
                                        iconContent = `<img src="${specificImagePath}" alt="${category.category} icon">`;
                                    } else {
                                        // Use fallback image if neither Lottie nor specific image found
                                        iconContent = `<img src="${fallbackImagePath}" alt="${category.category} icon">`;
                                    }
                                }
                            } catch (error) {
                                console.error(`Error checking icon for category ${categoryId}:`, error);
                                // Use fallback image on any fetch error
                                iconContent = `<img src="${fallbackImagePath}" alt="${category.category} icon">`;
                            }

                            categoriesHTML += `
                            <div class="component-item" data-category="${categoryId}">
                                <div class="component-icon">
                                    ${iconContent}
                                </div>
                                <div class="component-info">
                                    <h3 class="component-title">${category.category}</h3>
                                    <p class="component-card-description">${category.items.length} components</p>
                                </div>
                            </div>
                        `;
                        }
                    }));
                    categoriesHTML += '</div>';
                    let additionalContent = '';
                    try {
                        const response = await fetch('pages/ui-component-lib.html');
                        if (response.ok) {
                            additionalContent = await response.text();
                        }
                    } catch (error) {
                        console.error('Error loading ui-component-lib.html:', error);
                        additionalContent = '<p class="has-opacity">Additional content could not be loaded.</p>';
                    }

                    contentContainer.innerHTML = contentHeader + categoriesHTML + '<div class="additional-content">' + additionalContent + '</div>';
                    contentContainer.offsetWidth;
                    contentContainer.classList.remove('fade-out');
                    contentContainer.classList.add('fade-in');

                    setTimeout(() => {
                        document.querySelectorAll('.component-item').forEach(card => {
                            card.addEventListener('click', () => {
                                const categoryName = card.querySelector('.component-title').textContent;
                                document.querySelectorAll('.category-header').forEach(header => {
                                    const headerText = header.childNodes[0].textContent.trim();
                                    if (headerText === categoryName) {
                                        header.click();
                                    }
                                });
                            });
                        });
                        initializeVideos();
                        initializeImageSliders();
                        initializeLottieAnimations();
                        initializeScrollAnimations();
                        initializeElementScrollAnimations();
                        initPlaygrounds();
                        requestAnimationFrame(() => {
                            initializeTabSwitching();
                            initializeVideos();
                        });
                    }, 200);
                    contentContainer.classList.remove('fade-in');
                    return;
                }

                const response = await fetch(`pages/${pageName}.html`);
                if (!response.ok) {
                    throw new Error(`Failed to load ${pageName}`);
                }
                const html = await response.text();
                loadingIndicator.classList.remove('active');

                let componentName = pageName.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                menuData.forEach(category => {
                    const item = category.items.find(item =>
                        item.toLowerCase().replace(/\s+/g, '-').replace(/\//g, '-') === pageName
                    );
                    if (item) {
                        componentName = item;
                    }
                });

                const contentHeader = `
                    <div class="content-header">
                        <h1 class="content-title">‚ùñ ${componentName}</h1>
                    </div>
                `;

                contentContainer.innerHTML = contentHeader + html;
                contentContainer.offsetWidth;
                contentContainer.classList.remove('fade-out');
                contentContainer.classList.add('fade-in');

                requestAnimationFrame(() => {
                    injectComponentInfo(pageName);
                    initializeVideos();
                    initializeScrollAnimations();
                    initializeElementScrollAnimations();
                    initPlaygrounds();
                    requestAnimationFrame(() => {
                        initializeTabSwitching();
                        initializeVideos();
                        initializeLottieAnimations();
                        if (pageName === 'icons' && typeof initializeIconSearch === 'function') {
                            console.log('Detected icons page, initializing icon search...');
                            window.scrollTo({
                                top: 500,
                                behavior: 'instant'
                            });
                            setTimeout(() => {
                                window.scrollTo({
                                    top: 0,
                                    behavior: 'smooth'
                                });
                            }, 200);
                            setTimeout(initializeIconSearch, 300);
                            setTimeout(initializeElementScrollAnimations, 400);
                        }
                        if (typeof initializePropTables === 'function') {
                            console.log('Initializing property tables for dynamic content...');
                            initializePropTables();
                        }
                        if (pageName === 'empty-state-graphic') {
                            console.log('Initializing empty state toggle...');
                            const styleToggle = document.getElementById('styleToggle');
                            const emptyStateCards = document.querySelectorAll('.empty-state-card');
                            if (styleToggle && emptyStateCards.length > 0) {
                                styleToggle.addEventListener('change', function() {
                                    emptyStateCards.forEach(card => {
                                        card.classList.toggle('show-accent', this.checked);
                                    });
                                });
                            }
                        }
                        if (pageName === 'other-icons') {
                            console.log('Initializing other-icons content...');
                            loadSocialIcons();
                            loadPaymentIcons();
                            loadAppIcons();
                            loadIntegrationIcons();
                            loadEmojiIcons();
                            loadFlagIcons();
                            window.scrollTo({
                                top: 500,
                                behavior: 'instant'
                            });
                            setTimeout(() => {
                                window.scrollTo({
                                    top: 0,
                                    behavior: 'smooth'
                                });
                            }, 200);
                        }
                        if (pageName === 'latest-components') {
                            loadLatestComponents();
                        }
                    });
                });
                await new Promise(resolve => setTimeout(resolve, 200));
                contentContainer.classList.remove('fade-in');
            } catch (error) {
                console.error('Error loading content:', error);
                loadingIndicator.classList.remove('active');
                contentContainer.classList.remove('fade-out');
                contentContainer.innerHTML = `
                    <div class="content-header">
                        <h1 class="content-title">${pageName.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}</h1>
                        <p class="content-subtitle">Content not found or still in development</p>
                    </div>
                    <div style="text-align: center; padding: 50px;">
                        <p class="has-opacity">We're still working on this component. Check back soon!</p>
                    </div>
                `;
            }
        }

        // Add URL handling for browser navigation
        window.addEventListener('popstate', (event) => {
            if (event.state && event.state.page) {
                loadContent(event.state.page);
            } else {
                const path = window.location.pathname.substring(1) || 'ui-component-lib';
                loadContent(path);
            }
        });

        const debounceTime = 100;
        let debounceTimer;
        const maxWidth = window.innerWidth;
        function scaleContent() {
            const containers = document.querySelectorAll('.scalable-container');
            containers.forEach(container => {
                const content = container.querySelector('.scalable-content');
                if (!content) return;
                console.log(`scaleContent function executed`);
                if (!content.dataset.originalWidth || !content.dataset.originalHeight) {
                    const originalTransform = content.style.transform;
                    content.style.transform = 'none';
                    void content.offsetHeight;
                    if (!content.offsetWidth || content.offsetWidth < 10) {
                        content.style.width = maxWidth + 'px';
                        void content.offsetHeight;
                    }
                    content.dataset.originalWidth = content.offsetWidth || maxWidth;
                    content.dataset.originalHeight = content.offsetHeight || 300;
                    content.style.width = content.dataset.originalWidth + 'px';
                    content.style.height = content.dataset.originalHeight + 'px';
                    content.style.transform = originalTransform;
                }
                const availableWidth = Math.min(
                    container.clientWidth || document.documentElement.clientWidth,
                    maxWidth
                );
                const scale = availableWidth / content.dataset.originalWidth;
                content.style.transform = `scale(${scale})`;
                content.style.transformOrigin = 'top left';
                if (maxWidth < 900) {
                    const newHeight = (content.dataset.originalHeight * scale)/2;
                    container.style.height = `${newHeight}px`;
                    const newWidth = maxWidth;
                    content.style.width = `${newWidth}px`;
                    content.style.transform = `scale(${newWidth / 980})`;
                }
            });
        }

        // Function to extract protoId from figmaProto URL
            function extractProtoId(figmaProto) {
                const regex = /node-id=(\d+-\d+)/; // Regular expression to match the node-id
                const match = figmaProto.match(regex); // Execute the regex on the figmaProto string
                return match ? match[1] : null; // Return the protoId or null if not found
            }

        function injectComponentInfo(pageName) {
            setTimeout(() => {
                console.log(`Injecting data for component: ${pageName}`);
                const componentData = componentRepository[pageName];
                if (!componentData) {
                    console.log(`No stored data found for component: ${pageName}`);
                    return;
                }
                scaleContent();
                const descriptionElement = document.querySelector('.component-description p') ||
                    document.querySelector('.component-description') ||
                    document.querySelector('[data-description-container]');
                if (descriptionElement && componentData.description) {
                    console.log('Found description element, updating content');
                    descriptionElement.textContent = componentData.description;
                } else {
                    console.log('Description element not found in the DOM');
                }

                // Handle nested components if they exist
                if (componentData.nestedComponents && Array.isArray(componentData.nestedComponents) && componentData.nestedComponents.length > 0) {
                    console.log('Found nested components:', componentData.nestedComponents);

                    // Remove any existing nested components container to prevent duplicates
                    const existingContainer = document.querySelector('.nested-components-section');
                    if (existingContainer) {
                        existingContainer.remove();
                    }

                    // Create section for nested components
                    const nestedSection = document.createElement('div');
                    nestedSection.className = 'nested-components-section';

                    // Create header container for title and description
                    const headerContainer = document.createElement('div');
                    headerContainer.className = 'nested-section-header';

                    // Add title for nested components section
                    const sectionTitle = document.createElement('h3');
                    sectionTitle.className = 'section-title';
                    sectionTitle.textContent = 'Nested Components';
                    headerContainer.appendChild(sectionTitle);

                    const sectionDescription = document.createElement('p');
                    sectionDescription.className = 'section-description';
                    sectionDescription.textContent = 'The following items are used to setup this component:';
                    headerContainer.appendChild(sectionDescription);

                    nestedSection.appendChild(headerContainer);

                    // Create container for nested component buttons
                    const nestedContainer = document.createElement('div');
                    nestedContainer.className = 'nested-components-container';

                    // Create buttons for each nested component
                    componentData.nestedComponents.forEach(nestedId => {
                        const nestedData = componentRepository[nestedId];
                        if (nestedData) {
                            const button = document.createElement('a');
                            button.href = `#${nestedId}`;
                            button.className = 'nested-component-button';
                            button.innerHTML = `
                                ${nestedData.name}
                                <div class="diamond-icon">
                                    <div class="diamond-group">
                                        <div class="diamond-item"></div>
                                        <div class="diamond-item"></div>
                                        <div class="diamond-item"></div>
                                        <div class="diamond-item"></div>
                                    </div>
                                </div>
                            `;

                            // Add click handler to navigate to the nested component
                            button.addEventListener('click', (e) => {
                                e.preventDefault();
                                const itemId = nestedId;
                                document.querySelectorAll('.category-item').forEach(item => {
                                    if (item.getAttribute('data-page') === itemId) {
                                        item.click();
                                    }
                                });
                            });

                            nestedContainer.appendChild(button);
                        }
                    });

                    nestedSection.appendChild(nestedContainer);

                    // Find the appropriate insertion point - after the grid-2-col section
                    const gridSection = document.querySelector('.grid-2-col');
                    if (gridSection) {
                        gridSection.after(nestedSection);
                    } else {
                        // Fallback: insert after the Figma button if grid section not found
                        const figmaButton = document.querySelector('.two-tone-button');
                        if (figmaButton) {
                            const parentElement = figmaButton.parentElement;
                            parentElement.after(nestedSection);
                        }
                    }
                }

                const figmaLink = document.querySelector('.two-tone-button') ||
                    document.querySelector('[data-figma-link]') ||
                    document.querySelector('a[href*="figma.com"]');
                if (figmaLink && componentData.figmaLink) {
                    console.log('Found Figma link element, updating href');
                    figmaLink.setAttribute('href', componentData.figmaLink);
                    const buttonLeftElement = figmaLink.querySelector('.button-left');
                    if (buttonLeftElement && componentData.figmaButtonText) {
                        const diamondIcon = buttonLeftElement.querySelector('.diamond-icon');
                        const diamondHtml = diamondIcon ? diamondIcon.outerHTML : '';
                        buttonLeftElement.innerHTML = componentData.figmaButtonText + diamondHtml;
                    }
                } else {
                    console.log('Figma link element not found in the DOM');
                }
                            // Extract protoId from the figmaProto URL
                const figmaProto = componentRepository[pageName]?.figmaProto; // Assuming figmaProto contains the URL
                const protoId = figmaProto ? extractProtoId(figmaProto) : null; // Use the same method to extract protoId
                console.log(`ProtoId for ${pageName}: ${protoId}`); // Debugging line
                const figmaContainer = document.querySelector('[data-figma-link]');

                // Update the iframe src
                const iframe = document.querySelector('iframe'); // Select the iframe
                if (iframe && protoId) {
                    const currentSrc = iframe.getAttribute('src');
                    const newSrc = currentSrc.replace(/node-id=\d+-\d+/, `node-id=${protoId}`); // Replace the node-id
                    iframe.setAttribute('src', newSrc); // Set the new src
                }

                if (componentData.imagePath1 || componentData.imagePath2) {
                    console.log('Found image paths, searching for image elements');
                    const gridContainers = document.querySelectorAll('.grid-2-col');
                    gridContainers.forEach(gridContainer => {
                        const gridImages = gridContainer.querySelectorAll('.grid-item img[data-prop-img]');
                        if (gridImages.length > 0 && componentData.imagePath1) {
                            console.log('Updating first image src');
                            gridImages[0].setAttribute('src', componentData.imagePath1);
                            gridImages[0].setAttribute('alt', `${componentData.name} - diagram 1`);
                            const firstGridItem = gridImages[0].closest('.grid-item');
                            if (componentData.imagePath1.endsWith('empty.png')) {
                                if (firstGridItem) firstGridItem.classList.add('hidden');
                            } else {
                                if (firstGridItem) firstGridItem.classList.remove('hidden');
                            }
                        }
                        if (gridImages.length > 1 && componentData.imagePath2) {
                            console.log('Updating second image src');
                            gridImages[1].setAttribute('src', componentData.imagePath2);
                            gridImages[1].setAttribute('alt', `${componentData.name} - diagram 2`);
                            const secondGridItem = gridImages[1].closest('.grid-item');
                            if (componentData.imagePath2.endsWith('empty.png')) {
                                if (secondGridItem) secondGridItem.classList.add('hidden');
                            } else {
                                if (secondGridItem) secondGridItem.classList.remove('hidden');
                            }
                        }
                        const visibleGridItems = gridContainer.querySelectorAll('.grid-item:not(.hidden)');
                        if (visibleGridItems.length === 1) {
                            gridContainer.classList.add('single-column');
                        } else {
                            gridContainer.classList.remove('single-column');
                        }
                    });
                }
            }, 150);
            requestAnimationFrame(() => {
                initializeImageSliders();
            });
        }
        function saveComponentRepository() {
            localStorage.setItem('componentRepository', JSON.stringify(componentRepository));
            const jsonData = JSON.stringify(componentRepository, null, 2);
            const blob = new Blob([jsonData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'components.json';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            console.log('Component repository saved to downloadable JSON file');
            alert('Component data has been saved as components.json. To make this data available for future visits, please replace the components.json file in your project\'s data directory with this downloaded file.');
        }
        async function loadComponentRepository() {
            try {
                const response = await fetch('data/components.json');
                if (!response.ok) {
                    throw new Error(`Failed to load component data: ${response.status}`);
                }
                const loadedData = await response.json();
                Object.assign(componentRepository, loadedData);
                console.log('Component repository loaded from JSON file');
                localStorage.setItem('componentRepository', JSON.stringify(componentRepository));
            } catch (error) {
                console.error('Error loading component repository from file:', error);
                const storedData = localStorage.getItem('componentRepository');
                if (storedData) {
                    try {
                        const localData = JSON.parse(storedData);
                        Object.assign(componentRepository, localData);
                        console.log('Component repository loaded from localStorage fallback');
                    } catch (e) {
                        console.error('Error parsing localStorage data:', e);
                    }
                }
            } finally {
                populateComponentRepository();
            }
        }
        function closeSidebarOnMobile() {
            if (window.innerWidth <= 768) {
                const sidebar = document.getElementById('sidebar');
                sidebar.classList.remove('active');
                document.body.classList.remove('sidebar-open');
            }
        }
        document.querySelectorAll('.category-item').forEach(item => {
            item.addEventListener('click', (e) => {
                e.preventDefault();
                if (item.classList.contains('active')) {
                    return;
                }
                document.querySelectorAll('.category-item').forEach(i => {
                    i.classList.remove('active');
                });
                item.classList.add('active');
                const pageName = item.getAttribute('data-page');
                loadContent(pageName);
                scrollToTop();
                closeSidebarOnMobile();
            });
        });
        const sidebarToggle = document.getElementById('sidebar-toggle');
        const sidebar = document.getElementById('sidebar');
        const searchInput = document.getElementById('sidebarSearch');
        sidebarToggle.addEventListener('click', () => {
            sidebar.classList.toggle('active');
            document.body.classList.toggle('sidebar-open');
        });
        document.addEventListener('click', (e) => {
            if (!sidebar.contains(e.target) &&
                !sidebarToggle.contains(e.target)) {
                const activeItem = document.querySelector('.category-item.active');
                const activeCategory = activeItem ? activeItem.closest('.category') : null;
                if (searchInput.value) {
                    searchInput.value = '';
                    searchInput.dispatchEvent(new Event('input'));
                    if (activeItem && activeCategory) {
                        document.querySelectorAll('.category').forEach(cat => {
                            cat.classList.remove('active');
                            cat.querySelector('.toggle-icon').textContent = '‚óã';
                        });
                        activeCategory.classList.add('active');
                        activeCategory.querySelector('.toggle-icon').textContent = '‚¨§';
                        activeItem.classList.remove('hidden');
                        activeItem.classList.add('active');
                    }
                }
                if (window.innerWidth <= 768 && sidebar.classList.contains('active')) {
                    sidebar.classList.remove('active');
                    document.body.classList.remove('sidebar-open');
                }
            }
        });
        function addCategoryItemListeners() {
            document.querySelectorAll('.category-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.preventDefault();
                    const searchInput = document.getElementById('sidebarSearch');
                    const searchIcon = document.querySelector('.search-icon');
                    if (searchInput.value) {
                        searchInput.value = '';
                        searchIcon.src = 'assets/search.svg';
                        document.querySelectorAll('.category').forEach(cat => {
                            cat.classList.remove('hidden', 'search-active');
                            cat.querySelectorAll('.category-item').forEach(i => {
                                i.classList.remove('hidden');
                                const text = i.textContent.trim();
                                const indicator = i.querySelector('.category-item-indicator');
                                i.innerHTML = text + (indicator ? indicator.outerHTML : '');
                            });
                        });
                        document.getElementById('noResults').classList.remove('visible');
                    }
                    document.querySelectorAll('.category-item').forEach(i => {
                        i.classList.remove('active');
                    });
                    item.classList.add('active');
                    document.querySelectorAll('.category').forEach(cat => {
                        cat.classList.remove('active');
                        cat.querySelector('.toggle-icon').textContent = '‚óã';
                    });
                    const parentCategory = item.closest('.category');
                    if (parentCategory) {
                        parentCategory.classList.add('active');
                        parentCategory.querySelector('.toggle-icon').textContent = '‚¨§';
                    }
                    const pageName = item.getAttribute('data-page');
                    loadContent(pageName);
                    scrollToTop();
                    closeSidebarOnMobile();
                });
            });
        }

                function initializeVideos() {
                        console.log('Initializing videos...'); // Log when the function is executed
                        const videos = document.querySelectorAll('video');
                        if (videos.length === 0) {
                            console.log('No videos found.'); // Log if no videos are found
                            return; // Ensure this is inside the function
                        }
                        console.log('Videos found.'); // Log if no videos are found
                        videos.forEach((video, index) => {
                            video.id = `video-${index}`;
                            const videoContainer = video.closest('.video-container') || video.parentElement;

                            // Check for source elements and hide container if source is empty
                            const sources = videoContainer.querySelectorAll('source');
                            let hasValidSource = false;
                            sources.forEach(source => {
                                if (source.src) {
                                    hasValidSource = true;
                                } else {
                                    console.log(`Empty source found in video container: ${videoContainer.id || 'unknown'}`); // Log if an empty source is found
                                }
                            });
                            if (!hasValidSource) {
                                videoContainer.classList.add('hidden');
                                console.log(`Hiding video container: ${videoContainer.id || 'unknown'}`); // Log when hiding the container
                            }

                            if (!videoContainer.querySelector('.video-status-indicator')) {
                                const statusIndicator = document.createElement('div');
                                statusIndicator.className = 'video-status-indicator';
                                statusIndicator.textContent = 'Paused';
                                statusIndicator.id = `indicator-${index}`;
                                videoContainer.style.position = 'relative';
                                videoContainer.appendChild(statusIndicator);
                            }
                            const observer = new IntersectionObserver((entries) => {
                                entries.forEach(entry => {
                                    const indicator = document.getElementById(`indicator-${index}`);
                                    if (entry.isIntersecting) {
                                        videos.forEach(otherVideo => {
                                            if (otherVideo.id !== video.id) {
                                                otherVideo.pause();
                                                const otherIndex = otherVideo.id.split('-')[1];
                                                const otherIndicator = document.getElementById(`indicator-${otherIndex}`);
                                                if (otherIndicator) otherIndicator.textContent = 'Paused';
                                            }
                                        });
                                        if (video.paused) {
                                            const playPromise = video.play();
                                            if (playPromise !== undefined) {
                                                playPromise.then(() => {
                                                    if (indicator) indicator.textContent = 'Playing';
                                                }).catch(error => {
                                                    console.log("Auto-play prevented:", error);
                                                    if (indicator) indicator.textContent = 'Click to play';
                                                });
                                            }
                                        }
                                    } else {
                                        video.pause();
                                        if (indicator) indicator.textContent = 'Paused';
                                    }
                                });
                            }, {
                                threshold: 0.5
                            });
                            observer.observe(video);
                            video.addEventListener('click', () => {
                                const indicator = document.getElementById(`indicator-${index}`);
                                if (video.paused) {
                                    videos.forEach(otherVideo => {
                                        if (otherVideo.id !== video.id) {
                                            otherVideo.pause();
                                            const otherIndex = otherVideo.id.split('-')[1];
                                            const otherIndicator = document.getElementById(`indicator-${otherIndex}`);
                                            if (otherIndicator) otherIndicator.textContent = 'Paused';
                                        }
                                    });
                                    video.play();
                                    if (indicator) indicator.textContent = 'Playing';
                                } else {
                                    video.pause();
                                    if (indicator) indicator.textContent = 'Paused';
                                }
                            });
                            video.addEventListener('play', () => {
                                const indicator = document.getElementById(`indicator-${index}`);
                                if (indicator) indicator.textContent = 'Playing';
                            });
                            video.addEventListener('pause', () => {
                                const indicator = document.getElementById(`indicator-${index}`);
                                if (indicator) indicator.textContent = 'Paused';
                            });
                        });
                    }

        function initializeSearch() {
            const searchInput = document.getElementById('sidebarSearch');
            const noResults = document.getElementById('noResults');
            const searchIcon = document.querySelector('.search-icon');
            const searchIconPath = 'assets/search.svg';
            const closeIconPath = 'assets/close.svg';
            searchInput.addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase().trim();
                const categories = document.querySelectorAll('.category');
                let hasResults = false;
                searchIcon.src = searchTerm ? closeIconPath : searchIconPath;
                categories.forEach(category => {
                    const categoryHeader = category.querySelector('.category-header');
                    const categoryName = categoryHeader.textContent.trim().toLowerCase();
                    const items = category.querySelectorAll('.category-item');
                    let categoryHasVisibleItems = false;
                    items.forEach(item => {
                        const itemName = item.textContent.trim().toLowerCase();
                        const isMatch = itemName.includes(searchTerm) || categoryName.includes(searchTerm);
                        if (isMatch) {
                            item.classList.remove('hidden');
                            categoryHasVisibleItems = true;
                            hasResults = true;
                            if (searchTerm) {
                                const originalText = item.textContent.trim();
                                const regex = new RegExp(searchTerm, 'gi');
                                const highlightedText = originalText.replace(regex, match =>
                                    `<span class="highlight">${match}</span>`
                                );
                                const indicator = item.querySelector('.category-item-indicator');
                                item.innerHTML = `<span>${highlightedText}</span>` + (indicator ? indicator.outerHTML : '');
                            }
                        } else {
                            item.classList.add('hidden');
                        }
                    });
                    if (categoryHasVisibleItems || categoryName.includes(searchTerm)) {
                        category.classList.remove('hidden');
                        if (searchTerm) {
                            category.classList.add('active');
                            category.classList.add('search-active');
                        } else {
                            category.classList.remove('search-active');
                        }
                    } else {
                        category.classList.add('hidden');
                        category.classList.remove('search-active');
                        if (searchTerm) {
                            category.classList.remove('active');
                        }
                    }
                });
                noResults.classList.toggle('visible', !hasResults);
                if (!searchTerm) {
                    categories.forEach(category => {
                        category.classList.remove('hidden');
                        category.classList.remove('active');
                        category.classList.remove('search-active');
                        category.querySelectorAll('.category-item').forEach(item => {
                            item.classList.remove('hidden');
                            const text = item.textContent.trim();
                            const indicator = item.querySelector('.category-item-indicator');
                            item.innerHTML = text + (indicator ? indicator.outerHTML : '');
                        });
                    });
                    noResults.classList.remove('visible');
                }
            });
            searchIcon.addEventListener('click', () => {
                searchInput.value = '';
                searchInput.dispatchEvent(new Event('input'));
                searchIcon.src = searchIconPath;
            });
            searchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    searchInput.value = '';
                    searchInput.dispatchEvent(new Event('input'));
                    searchIcon.src = searchIconPath;
                    searchInput.blur();
                }
            });
        }
        window.initializeIconSearch = async function() {
            const searchInput = document.getElementById('iconSearchInput');
            const iconGrid = document.getElementById('iconGrid');
            const filterButtons = document.querySelectorAll('.filter-btn');
            const modal = document.getElementById('iconModal');
            const closeModalBtn = document.querySelector('.close-modal');
            const copyButtons = document.querySelectorAll('.copy-btn');
            const toast = document.getElementById('toast');
            let currentFilter = 'filled';
            let isLoading = true;
            let showingAllIcons = false;
            const ICONS_PER_PAGE = 100;
            let iconData = {};
            try {
                const response = await fetch('assets/icon_id_mapping/data.json');
                if (!response.ok) {
                    throw new Error('Failed to load icon data');
                }
                iconData = await response.json();
            } catch (error) {
                console.error('Error loading icon data:', error);
                iconGrid.innerHTML = '<div class="error-message">Failed to load icons. Please try again later.</div>';
                return;
            }
            const iconNames = Object.entries(iconData).map(([name, data]) => ({
                name,
                id: data.id
            }));
            function renderIcons(icons, forceShowAll = false) {
                iconGrid.innerHTML = '<div class="loading-message">Loading icons...</div>';
                isLoading = true;
                const tempContainer = document.createDocumentFragment();
                const iconsToRender = [];
                icons.forEach(icon => {
                    if (currentFilter === 'outline' && !icon.name.includes('outline')) return;
                    if (currentFilter === 'sharp' && !icon.name.includes('sharp')) return;
                    if (currentFilter === 'filled' && (icon.name.includes('outline') || icon.name.includes('sharp'))) return;
                    iconsToRender.push(icon);
                });
                if (iconsToRender.length === 0) {
                    iconGrid.innerHTML = '<div class="no-results">No icons found matching your search</div>';
                    isLoading = false;
                    return;
                }
                const showAll = forceShowAll || showingAllIcons;
                const iconsToShow = showAll ? iconsToRender : iconsToRender.slice(0, ICONS_PER_PAGE);
                const hasMoreIcons = iconsToRender.length > ICONS_PER_PAGE;
                iconsToShow.forEach(icon => {
                    const iconItem = document.createElement('div');
                    iconItem.className = 'icon-item';
                    iconItem.dataset.name = icon.name;
                    iconItem.dataset.id = icon.id;
                    iconItem.style.opacity = '0';
                    iconItem.style.transition = 'opacity 0.2s ease-in';
                    iconItem.innerHTML = `
                        <div class="icon-wrapper">
                            <ion-icon name="${icon.name}"></ion-icon>
                        </div>
                        <div class="icon-name">${icon.name}</div>
                    `;
                    iconItem.addEventListener('click', () => openIconModal(icon));
                    tempContainer.appendChild(iconItem);
                });
                iconGrid.innerHTML = '';
                iconGrid.appendChild(tempContainer);
                if (hasMoreIcons && !showAll) {
                    const showMoreContainer = document.createElement('div');
                    showMoreContainer.className = 'show-more-container';
                    showMoreContainer.innerHTML = `
                        <button class="show-more-button">
                            Show ${iconsToRender.length - ICONS_PER_PAGE} more
                        </button>
                    `;
                    showMoreContainer.querySelector('.show-more-button').addEventListener('click', () => {
                        showingAllIcons = true;
                        renderIcons(icons, true);
                    });
                    iconGrid.appendChild(showMoreContainer);
                }
                const iconElements = iconGrid.querySelectorAll('.icon-item');
                iconElements.forEach((icon, index) => {
                    setTimeout(() => {
                        icon.style.opacity = '1';
                    }, index * 5);
                });
                isLoading = false;

                // Apply scroll animations to icon items
                setTimeout(initializeElementScrollAnimations, 100);
            }
            function resetIconDisplay() {
                showingAllIcons = false;
            }
            function filterIcons() {
                resetIconDisplay();
                const searchTerm = searchInput.value.toLowerCase();
                const filteredIcons = iconNames.filter(icon => {
                    const matchesSearch = icon.name.toLowerCase().includes(searchTerm);
                    if (currentFilter === 'outline') return matchesSearch && icon.name.includes('outline');
                    if (currentFilter === 'sharp') return matchesSearch && icon.name.includes('sharp');
                    if (currentFilter === 'filled') return matchesSearch && !icon.name.includes('outline') && !icon.name.includes('sharp');
                    return false;
                });
                renderIcons(filteredIcons);
            }
            function openIconModal(icon) {
                const modalIconPreview = document.getElementById('modalIconPreview');
                const modalIconName = document.getElementById('modalIconName');
                const iconHtml = document.getElementById('iconHtml');
                const modal = document.getElementById('iconModal');

                modalIconName.textContent = icon.name;
                modalIconPreview.innerHTML = `
                    <ion-icon name="${icon.name}" size="large"></ion-icon>
                    <p id="modalIconName">${icon.name}</p>
                `;
                iconHtml.textContent = `<ion-icon name="${icon.name}"></ion-icon>`;
                iconReact.innerHTML = `
                    <a href="https://www.figma.com/design/t23EtqNAyknCBnrnaEOYwq/Allgemein?node-id=${icon.id}&t=OaCX3hbgJH9gzTAw-4" class="two-tone-button" target="_blank" data-figma-link>
                        <div class="button-left">${icon.name.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ')}<div class="diamond-icon">
                                <div class="diamond-group">
                                    <div class="diamond-item"></div>
                                    <div class="diamond-item"></div>
                                    <div class="diamond-item"></div>
                                    <div class="diamond-item"></div>
                                </div>
                            </div>
                        </div>
                        <div class="button-right">in figma anzeigen</div>
                    </a>
                `;
                modal.style.display = 'flex';
                // Force a reflow before adding the show class
                modal.offsetHeight;
                modal.classList.add('show');
            }
            function closeIconModal() {
                const modal = document.getElementById('iconModal');
                modal.classList.remove('show');
                modal.classList.add('hide');

                // Wait for animation to complete before hiding the modal
                setTimeout(() => {
                    modal.classList.remove('hide');
                    modal.style.display = 'none';
                }, 300);
            }
            function setupEventListeners() {
                searchInput.addEventListener('input', () => {
                    resetIconDisplay();
                    handleSearch();
                });

                // Add click event listener to document to handle clicks outside the search input
                document.addEventListener('click', (e) => {
                    const searchInput = document.getElementById('iconSearchInput');
                    const searchContainer = document.querySelector('.search-container');

                    // If click is outside the search container and input has value
                    if (!searchContainer.contains(e.target) && searchInput.value) {
                        searchInput.value = '';
                        resetIconDisplay();
                        filterIcons();
                    }
                });

                filterButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        resetIconDisplay();
                        filterButtons.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        currentFilter = btn.dataset.filter;
                        filterIcons();
                    });
                });

                closeModalBtn.addEventListener('click', () => {
                    closeIconModal();
                });

                window.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        closeIconModal();
                    }
                });

                // Add escape key handler for modal
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && modal.style.display !== 'none') {
                        closeIconModal();
                    }
                });

                copyButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const type = btn.dataset.copy;
                        let element;
                        switch (type) {
                            case 'html':
                                element = document.getElementById('iconHtml');
                                break;
                        }
                        const text = element.textContent;
                        copyToClipboard(text);
                        showToast();
                    });
                });
            }
            function handleSearch() {
                filterIcons();
            }
            function copyToClipboard(text) {
                const textarea = document.createElement('textarea');
                textarea.value = text;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
            }
            function showToast() {
                toast.classList.add('show');
                setTimeout(() => {
                    toast.classList.remove('show');
                }, 2000);
            }
            renderIcons(iconNames);
            setupEventListeners();
            console.log('Icon search component initialized');
        };

        async function loadLatestComponents() {
            console.log('Loading latest components...');

            // Define components to ignore
            const ignoreList = [
                'ui-component-lib',
                'documentation',
                'latest-components',
                'component-manager'
            ];

            // Get all components and filter out ignored ones
            const components = Object.entries(componentRepository)
                .filter(([id]) => !ignoreList.includes(id))
                .sort((a, b) => {
                    // Sort by last modified date if available, otherwise by name
                    const dateA = a[1].lastModified || '';
                    const dateB = b[1].lastModified || '';
                    return dateB.localeCompare(dateA);
                });

            // Get the last 10 components from the filtered list
            const lastTenComponents = components.slice(-10).reverse();

            // Create a container for the latest components
            const container = document.createElement('div');
            container.className = 'latest-components-container';

            // Add informational text about the display order
            const infoText = document.createElement('p');
            infoText.className = 'component-order-info';
            infoText.innerHTML = '<i>Note: Components are displayed in reverse chronological order. The most recently added component appears first in the grid.</i>';
            infoText.style.fontSize = '0.85rem';
            infoText.style.marginBottom = '20px';
            infoText.style.color = 'var(--description-color)';
            container.appendChild(infoText);

            // Create a grid for the components
            const grid = document.createElement('div');
            grid.className = 'components-grid';

            // Add each component as a button
            for (const [id, data] of lastTenComponents) {
                // Check if component-specific image exists
                const componentImagePath = `assets/img/${id}.png`;
                const defaultImagePath = 'assets/img/component.png';

                // Try to fetch the component-specific image
                try {
                    const response = await fetch(componentImagePath);
                    const imagePath = response.ok ? componentImagePath : defaultImagePath;

                    const button = document.createElement('a');
                    button.href = `#${id}`;
                    button.className = 'component-item';
                    button.innerHTML = `
                        <div class="component-icon">
                            <img src="${imagePath}" alt="${data.name} icon">
                        </div>
                        <div class="component-info">
                            <h3 class="component-title">‚ùñ\u00A0\u00A0${data.name}</h3>
                            <p class="component-card-description">${data.description || 'No description available'}</p>
                        </div>
                    `;

                    // Add click handler to navigate to the component
                    button.addEventListener('click', (e) => {
                        e.preventDefault();
                        document.querySelectorAll('.category-item').forEach(item => {
                            if (item.getAttribute('data-page') === id) {
                                item.click();
                            }
                        });
                    });

                    grid.appendChild(button);
                } catch (error) {
                    console.error(`Error checking image for component ${id}:`, error);
                    // Use default image if there's an error
                    const button = document.createElement('a');
                    button.href = `#${id}`;
                    button.className = 'component-item';
                    button.innerHTML = `
                        <div class="component-icon">
                            <img src="${defaultImagePath}" alt="${data.name} icon">
                        </div>
                        <div class="component-info">
                            <h3 class="component-title">‚ùñ\u00A0\u00A0${data.name}</h3>
                            <p class="component-card-description">${data.description || 'No description available'}</p>
                        </div>
                    `;

                    // Add click handler to navigate to the component
                    button.addEventListener('click', (e) => {
                        e.preventDefault();
                        document.querySelectorAll('.category-item').forEach(item => {
                            if (item.getAttribute('data-page') === id) {
                                item.click();
                            }
                        });
                    });

                    grid.appendChild(button);
                }
            }

            container.appendChild(grid);

            // Find the content container and append our new container
            const contentContainer = document.getElementById('content');
            const existingContent = contentContainer.querySelector('.latest-components-container');
            if (existingContent) {
                existingContent.remove();
            }
            contentContainer.appendChild(container);

            // Initialize animations for the new content
            initializeElementScrollAnimations();
        }

        async function initializeApp() {
            initializeSearch();
            const sidebarMenu = document.getElementById('sidebar-menu');
            const sortFabBtn = document.getElementById('sortFab');
            const sortToggleContainer = document.createElement('div');
            sortToggleContainer.className = 'sidebar-sort-toggle';
            sortToggleContainer.innerHTML = `
        <span id="sort-toggle-icon" class="sort-toggle-icon">üìã</span>
    `;
            sidebarMenu.insertBefore(sortToggleContainer, sidebarMenu.firstChild);
            const sortToggleIcon = document.getElementById('sort-toggle-icon');
            sortToggleIcon.addEventListener('click', toggleSidebarSorting);

            try {
                const response = await fetch('data/menu.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                menuData = await response.json(); // Assign fetched data
                console.log('Menu data loaded successfully.');

                // --- Now run code dependent on menuData ---

                // Generate initial sidebar menu using fetched data
                generateInitialSidebarMenu();

                await loadComponentRepository(); // Depends on menuData
                addCategoryItemListeners(); // Needs the items generated above

            // Get the initial page from URL parameters or default to ui-component-lib
            const page = getPageFromUrl();
                loadContent(page); // Depends on componentRepository which depends on menuData

            initializeVideos();
            initializeScrollAnimations();
            initializeElementScrollAnimations();

                // Simulate initial sort clicks (if needed, ensure menuData is available)
            setTimeout(() => {
                sortFabBtn.click();
                setTimeout(() => {
                    sortFabBtn.click();
                }, 100);
            }, 300);

                // Add Component Manager item (ensure menuData is available)
            setTimeout(() => {
                    let firstStepsCategory = null; // Find category element after generation
                    document.querySelectorAll('.category').forEach(categoryElement => {
                        const header = categoryElement.querySelector('.category-header');
                        if (header && header.textContent.trim().includes('First Steps')) {
                            firstStepsCategory = categoryElement;
                        }
                    });

                if (firstStepsCategory) {
                    const itemsContainer = firstStepsCategory.querySelector('.category-items');
                    if (itemsContainer) {
                        const managerItem = document.createElement('a');
                        managerItem.href = '#';
                        managerItem.className = 'category-item';
                        managerItem.setAttribute('data-item', 'Component Manager');
                        managerItem.setAttribute('data-page', 'component-manager');
                        managerItem.innerHTML = `
                Component Data Manager
                <span class="category-item-indicator"></span>
            `;
                        managerItem.addEventListener('click', (e) => {
                            e.preventDefault();
                            document.querySelectorAll('.category-item').forEach(i => {
                                i.classList.remove('active');
                            });
                            managerItem.classList.add('active');
                                createComponentManager(); // Ensure this function exists
                            scrollToTop();
                            closeSidebarOnMobile();
                        });
                        itemsContainer.appendChild(managerItem);
                    }
                }
            }, 300);
                 // --- End of code dependent on menuData ---

            } catch (error) {
                console.error('Error loading menu data:', error);
                // Display error message in content area
                const contentContainer = document.getElementById('content');
                contentContainer.innerHTML = '<p class="has-opacity">Error: Could not load sidebar menu data. Please ensure data/menu.json exists and is valid.</p>';
                // Optionally hide loading indicator
                const loadingIndicator = document.getElementById('loading');
                if(loadingIndicator) loadingIndicator.classList.remove('active');
            }
        };

        // New function to generate the initial sidebar based on menuData
        function generateInitialSidebarMenu() {
            const sidebarMenu = document.getElementById('sidebar-menu');
            // Clear existing items except the sort toggle
            const sortToggleContainer = sidebarMenu.querySelector('.sidebar-sort-toggle');
            const existingItems = sidebarMenu.querySelectorAll('.category');
            existingItems.forEach(item => item.remove()); // Remove only category divs

            menuData.forEach((menuItem, index) => {
                const categoryElement = document.createElement('div');
                categoryElement.className = 'category';
                // Set initial active state for "First Steps"
                if (menuItem.category === "First Steps") {
                    categoryElement.classList.add('active');
                }
                categoryElement.innerHTML = `
                    <div class="category-header">
                        ${menuItem.category}
                        <span class="toggle-icon">${menuItem.category === "First Steps" ? '‚¨§' : '‚óã'}</span>
                    </div>
                    <div class="category-items">
                        ${menuItem.items.map(item => {
                        // Set initial active state for "UI component lib"
                        const isActive = item === "UI component lib" && menuItem.category === "First Steps" ? "active" : "";
                        const itemId = item.toLowerCase().replace(/\s+/g, '-').replace(/\//g, '-');
                        return `
                                <a href="#" class="category-item ${isActive}" data-item="${item}" data-page="${itemId}">
                                    ${item}
                                    <span class="category-item-indicator"></span>
                                </a>
                            `;
                    }).join('')}
                    </div>
                `;
                sidebarMenu.appendChild(categoryElement);
            });

            // Add category header click listeners after generation
            document.querySelectorAll('.category-header').forEach(header => {
                header.addEventListener('click', () => {
                    const parent = header.parentElement;
                    const toggleIcon = header.querySelector('.toggle-icon');
                    const isActive = parent.classList.contains('active');

                    // Deactivate all categories and items first
                    document.querySelectorAll('.category').forEach(cat => {
                        if (cat !== parent) { // Don't deactivate self yet
                           cat.classList.remove('active');
                           cat.querySelector('.toggle-icon').textContent = '‚óã';
                        }
                    });
                    // Deactivate all items (safer approach)
                     document.querySelectorAll('.category-item').forEach(i => {
                        i.classList.remove('active');
                    });

                    // Activate the clicked category and its first item if it wasn't already active
                    if (!isActive) {
                        parent.classList.add('active');
                        toggleIcon.textContent = '‚¨§';
                        const firstItem = parent.querySelector('.category-item');
                        if (firstItem) {
                            firstItem.classList.add('active'); // Activate first item
                            const pageName = firstItem.getAttribute('data-page');
                            loadContent(pageName);
                            // updateNavigationTooltips(); // Check if this function exists and is needed
                            scrollToTop();
                            closeSidebarOnMobile();
                            scrollToCategoryItems(parent);
                        }
                    } else {
                         // If already active, deactivate it (toggle behavior)
                         parent.classList.remove('active');
                         toggleIcon.textContent = '‚óã';
                         // Optionally load default page or do nothing
                         // loadContent('ui-component-lib');
                    }
                });
            });
        }

        // Remove the original hardcoded sidebar generation loop
        // ... (The loop from approx line 548 to 569 should be removed)
        // Ensure it's fully removed

        // ... rest of the existing script ...

        const themeToggle = document.getElementById('theme-toggle');
        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
            document.documentElement.setAttribute('data-theme', 'dark');
            themeToggle.checked = true;
        }
        themeToggle.addEventListener('change', function () {
            if (this.checked) {
                document.documentElement.setAttribute('data-theme', 'dark');
                localStorage.setItem('theme', 'dark');
            } else {
                document.documentElement.setAttribute('data-theme', 'light');
                localStorage.setItem('theme', 'light');
            }
        });
        window.addEventListener('DOMContentLoaded', () => {
            initializeApp();

            // Apply initial animations to elements in the viewport
            setTimeout(() => {
                initializeElementScrollAnimations();
            }, 300);
        });

        function openHowToModal() {
            console.log('Opening modal...');
            const modal = document.getElementById('howToModal');
            modal.style.display = 'flex';
            // Force a reflow before adding the show class
            modal.offsetHeight;
            modal.classList.add('show');
            document.body.style.overflow = 'hidden';

            // Get the animation container
            const container = modal.querySelector('.animation-container');
            if (container) {
                // Clear the container
                container.innerHTML = '';

                // Get the animation path
                const animationPath = container.getAttribute('data-lottie-path');

                // Fetch the animation data
                fetch(animationPath)
                    .then(response => response.json())
                    .then(animationData => {
                        // Create new animation with the fetched data
                        const animation = lottie.loadAnimation({
                            container: container,
                            renderer: 'svg',
                            loop: true,
                            autoplay: true,
                            animationData: animationData
                        });

                        // Store the animation instance
                        container.animation = animation;
                    })
                    .catch(error => {
                        console.error('Error loading animation:', error);
                        container.innerHTML = '<div style="color: red;">Animation failed to load</div>';
                    });
            }
        }

        function closeHowToModal() {
            const modal = document.getElementById('howToModal');
            modal.classList.remove('show');
            modal.classList.add('hide');

            // Get the animation container
            const container = modal.querySelector('.animation-container');
            if (container && container.animation) {
                container.animation.destroy();
                container.animation = null;
            }

            // Wait for animation to complete before hiding the modal
            setTimeout(() => {
                modal.classList.remove('hide');
                modal.style.display = 'none';
                document.body.style.overflow = '';
            }, 500);
        }

        // Add event listeners for the how-to modal
        document.addEventListener('DOMContentLoaded', function() {
            const howToModal = document.getElementById('howToModal');
            const closeModalBtn = howToModal.querySelector('.close-modal');

            closeModalBtn.addEventListener('click', closeHowToModal);

            window.addEventListener('click', (e) => {
                if (e.target === howToModal) {
                    closeHowToModal();
                }
            });

            // Add escape key handler for modal
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && howToModal.style.display !== 'none') {
                    closeHowToModal();
                }
            });
        });

        // Add URL parameter handling
        function getPageFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            const pageParam = urlParams.get('page');
            return pageParam || 'ui-component-lib';
        }

        // Update the popstate event handler
        window.addEventListener('popstate', (event) => {
            const page = getPageFromUrl();
            loadContent(page);
        });

        // Add a function to handle direct URL access
        function handleDirectUrlAccess() {
            const currentUrl = window.location.href;
            if (!currentUrl.includes('index.html')) {
                const page = getPageFromUrl();
                const newUrl = page === 'ui-component-lib' ? '/index.html' : `/index.html?page=${page}`;
                window.history.replaceState({ page: page }, '', newUrl);
            }
        }

        // Call handleDirectUrlAccess when the page loads
        window.addEventListener('load', handleDirectUrlAccess);

        function scrollToCategoryItems(category) {
            const categoryItems = category.querySelector('.category-items');
            if (categoryItems) {
                const sidebar = document.getElementById('sidebar');
                const categoryRect = category.getBoundingClientRect();
                const sidebarRect = sidebar.getBoundingClientRect();
                const viewportMiddle = sidebarRect.height / 2;

                // Only scroll if the category is below the middle of the viewport
                if (categoryRect.top > viewportMiddle) {
                    // Calculate a more balanced scroll position that keeps items in the middle third of the viewport
                    const targetPosition = viewportMiddle - (categoryRect.height / 2);
                    const scrollTop = categoryRect.top - sidebarRect.top + sidebar.scrollTop - targetPosition;

                    // Add a small delay to ensure the items are expanded
                    setTimeout(() => {
                        sidebar.scrollTo({
                            top: scrollTop,
                            behavior: 'smooth'
                        });
                    }, 100);
                }
            }
        }
    </script>
    <!-- Property Table System -->
    <script src="js/include-prop-tables.js"></script>
    <!-- Animation JavaScript -->
    <script>
        // Initialize ScrollTrigger plugin
        gsap.registerPlugin(ScrollTrigger);

        // Wait for DOM to be ready
        $(document).ready(function() {
            // Process has-mask-fill elements
            $('.has-mask-fill').each(function () {
                var words = $(this).text();
                var total = words;
                $(this).empty();
                $(this).append($("<span /> ").text(words));
            });

            // Special handling for block-title elements
            $('.has-mask-fill.block-title').each(function() {
                var words = $(this).text().split(" ");
                var total = words.length;
                $(this).empty();
                for (index = 0; index < total; index++) {
                    $(this).append($("<span /> ").text(words[index] + " "));
                }
            });

            // Animate has-mask-fill elements
            var hasMaskFill = gsap.utils.toArray('.has-mask-fill');
            hasMaskFill.forEach(function(hMaskFill) {
                var spanFillMask = hMaskFill.querySelectorAll("span");
                gsap.to(spanFillMask, {
                    scrollTrigger: {
                        trigger: hMaskFill,
                        start: "top 85%",
                        end: () => `+=${hMaskFill.offsetHeight * 2}`,
                        scrub: 1,
                    },
                    duration: 1,
                    backgroundSize: "200% 100%",
                    stagger: 0.5,
                    ease: "none",
                });
            });

            // Process has-opacity elements
            $('.has-opacity').each(function() {
                var words = $(this).text().split(" ");
                var total = words.length;
                $(this).empty();
                for (index = 0; index < total; index++) {
                    $(this).append($("<span /> ").text(words[index] + " "));
                }
            });

            // Animate has-opacity elements
            var hasOpacity = gsap.utils.toArray('.has-opacity');
            hasOpacity.forEach(function(hOpacity) {
                var spanOpacity = hOpacity.querySelectorAll("span");
                gsap.to(spanOpacity, {
                    scrollTrigger: {
                        trigger: hOpacity,
                        start: "top 85%",
                        end: () => `+=${hOpacity.offsetHeight}`,
                        scrub: 1,
                    },
                    duration: 1,
                    opacity: 1,
                    stagger: 0.5,
                    ease: "none",
                });
            });
        });
    </script>
    <!-- How-to Modal -->
    <div id="howToModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>How to Use the ‚ùñ Component Library</h2>
                <button class="close-modal" onclick="closeHowToModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="animation-container" data-lottie-path="assets/lottie/modal_tut.json" data-lottie-loop="true" data-lottie-autoplay="false">
                </div>
                <div class="tutorial-info">
                    <p>Here's how to access components in Figma:</p>
                    <ul>
                        <li>Click the navigation icon in Figma and switch to the Assets panel</li>
                        <li>Search for your desired component in the search bar</li>
                        <li>Quick tip: Use <kbd>Shift</kbd> + <kbd>I</kbd> to open the component search directly</li>
                        <li>Or simply click the "Open in Figma" button on any component page to view it directly</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</body>
</html>